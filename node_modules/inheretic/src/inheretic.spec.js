describe('index', () => {
  const fs = require('fs');
  const path = require('path');
  const index = require('./inherit');

  beforeAll(() => {
    fs.mkdirSync('./tmp');
    require('fs-extra').copySync('example-app', './tmp');
  });
  afterAll((done) => {
    require('rimraf')('./tmp', done);
  });

  describe('findPackages', () => {
    const parent = path.join(__dirname + '/../', 'tmp');
    it('finds package.json files', () => {
      const packages = index.findPackages(parent, 'package.json');
      expect(packages.length).toEqual(1);
      const pkg = packages[0].replace(/\\/g, '/'); // windows
      expect(pkg.endsWith("/tmp/package.json")).toBe(true);
    });
    it('finds template.package.json files', () => {
      const packages = index.findPackages(parent, 'template.package.json');
      expect(packages.length).toEqual(5);
      const pkgs = packages.map((pkg) => pkg.replace(/\\/g, '/')).sort(); // windows
      expect(pkgs[0].endsWith("/child-leaf/template.package.json")).toBe(true);
      expect(pkgs[1].endsWith("/child-no-parent/template.package.json")).toBe(true);
      expect(pkgs[2].endsWith("/child-root/template.package.json")).toBe(true);
      expect(pkgs[3].endsWith("/child-siblings-twin/template.package.json")).toBe(true);
      expect(pkgs[4].endsWith("/child-siblings/template.package.json")).toBe(true);
    });
  });

  describe('merge', () => {
    it('merges property from parent to child if undefined in child', () => {
      const parent = {prop:'value'};
      const child = {};
      index.merge(parent, child);
      expect(child).toEqual(parent);
    });
    it('wont merge property from parent to child if defined in child', () => {
      const parent = {prop:'value'};
      const child = {prop:'overridden'};
      index.merge(parent, child);
      expect(child).toEqual({prop:'overridden'});
    });
    it('merges property from parent to child if nested in object within child', () => {
      const parent = {prop:{key1:'value1'}};
      const child = {prop:{key2:'value2'}};
      index.merge(parent, child);
      expect(child).toEqual({prop:{key2:'value2', key1:'value1'}});
    });
    it('merges property from parent to child if deeply nested in object within child', () => {
      const parent = {prop:{key:{nested1:'value1'}}};
      const child = {prop:{key:{nested2:'value2'}}};
      index.merge(parent, child);
      expect(child).toEqual({prop:{key:{nested2:'value2', nested1:'value1'}}});
    });
    it('wont merge property from parent to child if deeply nested in object within child and same key', () => {
      const parent = {prop:{key:{nested:'value1'}}};
      const child = {prop:{key:{nested:'value2'}}};
      index.merge(parent, child);
      expect(child).toEqual({prop:{key:{nested:'value2'}}});
    });
    it('merges array contents from parent to child if not contained in child array', () => {
      const parent = {prop:[0]};
      const child = {prop:[1]};
      index.merge(parent, child);
      expect(child).toEqual({prop:[1, 0]});
    });
    it('will not merge array contents from parent to child if contained in child array', () => {
      const parent = {prop:[0]};
      const child = {prop:[0]};
      index.merge(parent, child);
      expect(child).toEqual({prop:[0]});
    });
  });

  describe('inherit', () => {
    const merge = index.merge;
    afterAll(() => {
      index.merge = merge;
    });
    it('does nothing if child is already generated', () => {
      const child = {_generated: true};
      index.inherit(undefined, child);
      expect(child).toEqual({_generated: true});
    });
    it('writes out the merge of parent template onto child template, without _filename key', () => {
      const writer = {writer: () => {}};
      spyOn(writer, 'writer').and.returnValue(undefined);
      index.merge = (parent, child) => { };
      index.inherit({meh: 'whatever'},
                    {nothing_to_merge: true, _filename: 'whatever'},
                    writer.writer);
      expect(writer.writer).toHaveBeenCalledWith(
        'package.json', '{\n    "nothing_to_merge": true\n}');
    });
  });

  describe('chainInherit', () => {
    const inherit = index.inherit;
    afterAll(() => {
      index.inherit = inherit;
    });
    it('terminates', () => {
      expect(index.chainInherit({})).toBe(undefined);
    });
    it('inherits from parent to child', () => {
      const child = {ck:'cv', _filename: '/child', parent: '/parent'};
      const parent = {pk:'pv'};
      spyOn(index, 'inherit');
      index.chainInherit({'/child': {child: child, parent: parent}}, fs.writeFileSync);
      expect(index.inherit).toHaveBeenCalledWith(parent, child, fs.writeFileSync);
    });
    describe('when order may matter', () => {
      const parent = {pk:'pv', _filename: '/parent'};
      const child = {ck:'cv', _filename: '/child', parent: '/parent'};
      const grandchild = {gk:'gv', _filename: '/grandchild', parent: '/child'};
      function assertInheritanceEldestFirst(families){
        const callOrder = []
        index.inherit = (parent, child) => callOrder.push({
          parent:parent, child:child
        });
        index.chainInherit(families(parent, child, grandchild));
        expect([
          {parent: parent, child: child},
          {parent: child,  child: grandchild}
        ]).toEqual(callOrder);
      }
      it('inherits from parent -> child -> grandchild', () => {
        assertInheritanceEldestFirst((parent, child, grandchild) => {
          return {
            '/child': {child: child, parent: parent},
            '/grandchild': {child: grandchild, parent: child}
          };
        });
      });
      it('inherits from parent -> child -> grandchild - compliment', () => {
        assertInheritanceEldestFirst((parent, child, grandchild) => {
          return {
            '/grandchild': {child: grandchild, parent: child},
            '/child': {child: child, parent: parent}
          };
        });
      });
    });
  });

  describe('packageToFamily', () => {
    const resolve = (file) => path.resolve(path.dirname(file), file);
    function fileSystem(files) {
      Object.keys(files).forEach((file) => {
        const tmp = resolve(file);
        files[tmp] = files[file];
        if(file !== tmp) delete files[file];
      });
      function fileContents(file) {
        return files[resolve(file)];
      }
      return { readFileSync: fileContents, existsSync: fileContents };
    }
    it('creates the json for package.json it, and it\'s parent; links them', () => {
      const packageToFamily = index.packageToFamily(fileSystem({
        '/child': '{"parent":"/parent"}', 
        '/parent': '{"ya":"buddy"}'
      }));
      expect([{parent: {ya:'buddy', _filename: resolve('/parent')}, 
               child: {parent:'/parent', _filename: resolve('/child')}}])
        .toEqual(packageToFamily(resolve('/child')));
    });
    it('returns [] if no parent', () => {
      const packageToFamily = index.packageToFamily(fileSystem({
        '/child': '{"yoyoyo":"boyeeeeee"}', 
        '/parent': '{"ya":"buddy"}'
      }));
      expect([]).toEqual(packageToFamily(resolve('/child')));
    });
  });

});
